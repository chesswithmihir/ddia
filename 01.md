# Chapter 1 Reliable, Scalable, and Maintainable Systems

## Introduction

> The Internet was done so well that most people think of it as a natural resource like the
Pacific Ocean, rather than something that was man-made. When was the last time a tech‐
nology with a scale like that was so error-free? <br>
—Alan Kay, in interview with Dr Dobb’s Journal (2012)

Many applications today are data-intensive (contrasted with CPU intensive because raw CPU power is rarely a limiting factor for these applications. Bigger problems are usually in the amount, complexity, and speed of data.

Data intensive apps have building blocks that provide for its functionality
- Store data so another app can find the data (DB)
- remember the result of an expensive operation (cache)
- query data via searching of keywords or filters (search indexes)
- send messages to another process to be handled asynchronously (stream processing)
- periodicaly crunch a large amount of accumulated data (batch processing)

Often there is no need to shift away from this abstraction since it's become perfected over time.

However, it's not enough to have these abstractions and call it a day. Many DB systems exist with different characteristics and support different requirements. When building an application, we need to figure out which tool and which approaches are most appropriate for the task at hand. And it can be hard to combine tools when you need to do something that a single tool cannot do alone.

Let's first go over what it means to have reliable, scalable, and maintainble data systems.

## Thinking about Data Systems

Why lump DB, queues, caches, etc all in Data Systems?

Many new tools for data storage and processing have emreged in recent years. They are optimized for a variety of different use cases, and they no longer neatly fit into traditional categories. For example, there are datastores that are also used as message queues (Redis), and there are message queues with database-like durability guarantees (Apache Kafka). The boundaries between the categories are becoming blurred. 

many apps now have demanding or wide-ranging reqs that a single tool can no longer meet all of its data processing and storage needs. Instead the work is broken down into tasks that can be perfomed efficinetly on a single tools, and those different tools are stitched together using application code.

For example, if you have an application-managed caching layer (using memcached or similar) or a full-text search server such as Elasticsearch or Solr) separate from your main db, it's normally the app code's responsibility to keep those cahces and indexes in sync with the main db. 

<img width="967" alt="Screenshot 2024-07-20 at 11 45 39 AM" src="https://github.com/user-attachments/assets/fcd52cbe-4e98-46d3-ae23-4a3206648d52">


